<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sorock documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="multi-raft.html"><strong aria-hidden="true">1.</strong> Multi-Raft</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="heartbeat-multiplexing.html"><strong aria-hidden="true">1.1.</strong> Heartbeat Multiplexing</a></li><li class="chapter-item expanded "><a href="batched-write.html"><strong aria-hidden="true">1.2.</strong> Batched Write</a></li></ol></li><li class="chapter-item expanded "><a href="raft-process.html"><strong aria-hidden="true">2.</strong> Raft Process</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="multi-threading.html"><strong aria-hidden="true">2.1.</strong> Multi Threading</a></li><li class="chapter-item expanded "><a href="application-state.html"><strong aria-hidden="true">2.2.</strong> Application State</a></li></ol></li><li class="chapter-item expanded "><a href="client-interaction.html"><strong aria-hidden="true">3.</strong> Client Interaction</a></li><li class="chapter-item expanded "><a href="cluster-management.html"><strong aria-hidden="true">4.</strong> Cluster Management</a></li><li class="chapter-item expanded "><a href="leadership.html"><strong aria-hidden="true">5.</strong> Leadership</a></li><li class="chapter-item expanded "><a href="development.html"><strong aria-hidden="true">6.</strong> Development</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sorock documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="multi-raft"><a class="header" href="#multi-raft">Multi-Raft</a></h1>
<p><a href="https://raft.github.io/">Raft</a> consensus algorithm is nowadays a widely used building block of distributed applications.
The algorithm is about consensus on the sequence of log entries, which are applied to a state machine.
When the two log entries are identical, then the resulting state is identical too.
In this sense, it is also called <strong>replicated state machine</strong>.</p>
<p>The typical usage of the Raft algorithm is to implement a distributed key-value store.
However, naive implementation will suffer from scalability issues due to the seriality of the algorithm.
Let's consider putting (k1,v1) and (k2,v2) in the data store, naive implementation can't handle these two concurrently
because the operations are serialized.</p>
<p>Sharding is a common solution to this kind of problem.
If the k1 and k2 are enough distant in the key space, then the operations can be handled concurrently
by sharded Raft clusters.
Since we can split the single Raft cluster into multiple small Raft clusters,
it naturally addresses the capacity scalability problem at the same time.
TiKV uses this technique (<a href="https://tikv.org/deep-dive/scalability/multi-raft/">ref</a>).</p>
<p><img src="images/multi-raft-tikv.png" alt="" /></p>
<p>There are two ways of implementing a multi-raft.
One is deploying multiple Raft clusters independently.
One of the problems of this approach is that resources like IP addresses or ports must be
allocated per node to identify them.
This introduces unnecessary complexity in deployment.
Another problem is that shards can't share the resources efficiently.
In the implementation of a key-value store, the embedded datastore should be shared among the shards
for efficient I/O like write batching.
For these problems, I will take the second approach.</p>
<p>sorock implements <strong>in-process multi-raft</strong>.
As the name implies, sorock allows you to place multiple <strong>Raft processes</strong> in a single gRPC server process.
These Raft processes can form a Raft cluster on independent <strong>shards</strong>.</p>
<p><img src="images/multi-raft.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heartbeat-multiplexing"><a class="header" href="#heartbeat-multiplexing">Heartbeat Multiplexing</a></h1>
<p>In Raft, leader is responsible for periodically sending heartbeats to all followers to maintain the leadership.
In Multi-Raft, without any optimization load from the the heartbeats can be non-negligible.
However, we can optimize to reduce the heartbeat RPCs by multiplexing the heartbeats from different shards.</p>
<h2 id="problem-of-naive-implementation"><a class="header" href="#problem-of-naive-implementation">Problem of naive implementation</a></h2>
<p>In the following diagram, we have two nodes Node1 and Node2 and there are two shards.
A Process is a leader if it is denoted with an asterisk (*):
P1 is sending the heartbeats to the P3 and P2 to P4 as well.
So there are two RPC messages sent from P1 to P3 and P2 to P4 independently.</p>
<pre class="mermaid">graph LR
  subgraph Node1
    P1(P1*)
    P2(P2*)
  end
  subgraph Node2
    P3(P3)
    P4(P4)
  end
  P1 --&gt;|heartbeat| P3
  P2 --&gt; P4
</pre>
<h2 id="multiplexing-heartbeats"><a class="header" href="#multiplexing-heartbeats">Multiplexing heartbeats</a></h2>
<p>To reduce the number of RPCs to only one, we can introduce multiplexer and demultiplexer in the nodes.
The two heartbeats are buffered in the multiplexer and sent in a batched RPC to the destination node.
In the destination node, the demultiplexer will split the batched RPC into individual heartbeats
and send them to the corresponding processes.</p>
<pre class="mermaid">graph LR
  subgraph Node1
    P1(P1*)
    P2(P2*)
    MUX(Mux)
  end
  subgraph Node2
    DEMUX(Demux)
    P3(P3)
    P4(P4)
  end
  P1 --&gt; MUX
  P2 --&gt; MUX
  MUX --&gt; DEMUX
  DEMUX --&gt; P3
  DEMUX --&gt; P4
</pre>
<p>In this case the reduction rate is 2.
But what would be the reduction rate in general.
Let's do some math.</p>
<h2 id="math-reduction-rate"><a class="header" href="#math-reduction-rate">Math: Reduction rate</a></h2>
<p>Let's consider there are N nodes and L shards.
Each shard have K replication and leader processes are
balanced among the nodes.</p>
<p>In this case,
the total number of heartbeats sent in period is LK.
And the total directed paths connecting two nodes is N(N-1) and
these heartbeats are evenly attributed to these paths.
Therefore, the number of heartbeats sent in each path is LK/(N(N-1))
and this is the reduction rate.
For example, if there are 5 nodes and 1000 shards with 3 replication,
the reduction rate is 150.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="batched-write"><a class="header" href="#batched-write">Batched Write</a></h1>
<p>In multi-raft, multiple shards process write requests. Conceptually, each shard maintains its own log for entry insertion.</p>
<p>Having a physically independent log for each shard isn't efficient as each write requires a transaction to persist the data on the storage.</p>
<p>However, an optimization technique called "batching" can be used. Here, each shard maintains a virtual log, and the entries are temporarily queued in a shared queue. These queued entries are then processed in a single transaction, reducing the number of transactions.</p>
<p>This approach often presents a throughput versus latency dilemma. However, this implementation increases throughput without sacrificing latency.</p>
<pre class="mermaid">graph LR
  CLI(Client)

  subgraph P1
    T1(redb::Table)
  end
  subgraph P2
    T2(redb::Table)
  end
  subgraph P3
    T3(redb::Table)
  end

  subgraph Reaper
    Q(Queue)
  end
  DB[(redb::Database)]

  CLI --&gt;|entry| T1
  CLI --&gt; T2
  CLI --&gt; T3
  T1 --&gt;|lazy entry| Q
  T2 --&gt; Q
  T3 --&gt; Q
  Q --&gt;|transaction| DB

</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raft-process"><a class="header" href="#raft-process">Raft Process</a></h1>
<p>The core of multi-raft is Raft process.
Each multi-raft server has one or more Raft processes.</p>
<p>To implement multi-raft,
sorock implements Raft process as it is agnostic to
detailed node communications through gRPC.
Since the Raft process doesn't know about the IO,
we call it <strong>Pure Raft</strong>.</p>
<p><img src="images/raft-process.png" alt="" /></p>
<p>To make Raft process to communicate with other Raft processes
through network, <code>RaftDriver</code> must be provided.
Everything about actual network communication is encapsulated under <code>RaftDriver</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RaftProcess {
    pub async fn new(
        app: impl RaftApp,
        log_store: impl RaftLogStore,
        ballot_store: impl RaftBallotStore,
        driver: RaftDriver,
    ) -&gt; Result&lt;Self&gt; {
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-threading"><a class="header" href="#multi-threading">Multi Threading</a></h1>
<p>Inside RaftProcess, there is a state called <code>RaftCore</code> and
many threads to process it concurrently on an event-driven basis,
most of them are driven by timers.</p>
<p><img src="images/multi-threading.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-state"><a class="header" href="#application-state">Application State</a></h1>
<p>In RaftCore, <code>RaftApp</code> and <code>RaftLogStore</code> are especially important because
these two compose the application state.
This section explains the conceptual aspect of it.</p>
<p><img src="images/application-state.png" alt="" /></p>
<h2 id="raftapp"><a class="header" href="#raftapp">RaftApp</a></h2>
<p><code>RaftApp</code> is an abstraction that represents the FSM (Finite State Machine) of the application
and the snapshot repository.
The snapshot repository isn't separated because the contents of the snapshot is
strongly coupled with the application state.</p>
<p>The application state can be updated by applying the log entries.
In this figure, the last applied entry is of index 55.</p>
<p><code>RaftApp</code> can generate a snapshot arbitrarily to compact the log.
When <code>RaftApp</code> makes a snapshot and stores it in the snapshot repository.
The latest snapshot is immediately picked up by the Raft process and it
manipulates the log (right in the figure) by replacing the snapshot entry.
In this figure, the snapshot index is 51.</p>
<p>Old snapshots will be garbage collected.</p>
<p>Snapshots may be fetched from other nodes.
This happens when the Raft process is far behind the leader and
the leader doesn't have the log entries as they are garbage collected.</p>
<h2 id="raftlogstore"><a class="header" href="#raftlogstore">RaftLogStore</a></h2>
<p><code>RaftLogStore</code> is an abstraction that represents the log entries.
In the figure, log entries from 45 to 50 are scheduled for garbage collection.
snapshot entry is of index 51 and it is guaranteed that the corresponding snapshot
exists in the snapshot repository. 52 to 55 are applied.
56 or later are not applied yet. They are either uncommitted or committed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-interaction"><a class="header" href="#client-interaction">Client Interaction</a></h1>
<p>You can send application-defined commands to the Raft cluster.</p>
<p>sorock distinguishes the command into two types: read-write and read-only.
The read-only command is called <strong>query</strong> and queries can be processed through the optimized path.</p>
<h2 id="rw-commnand"><a class="header" href="#rw-commnand">R/W commnand</a></h2>
<p>R/W command is a normal application command that is inserted into the log to be applied later.</p>
<p>You can send a R/W command to the cluster with this API.</p>
<pre><code class="language-proto">message WriteRequest {
  uint32 shard_id = 1;
  bytes message = 2;
  string request_id = 3;
}
</code></pre>
<p><strong>request_id</strong> is to avoid doubly application.
Let's think about this scenario:</p>
<ol>
<li>The client sends a R/W command to add 1 to the value.</li>
<li>The leader server replicates the command to the followers but crashes before application (+response).</li>
<li>The client resends the command to a new leader after a timeout.</li>
<li>The result is adding 2 to the value whereas the expectation is 1.</li>
</ol>
<p>To avoid this issue, request_id is added to identify the commands.</p>
<h2 id="ro-command"><a class="header" href="#ro-command">R/O command</a></h2>
<p>The R/O command can bypass the log because it is safe to execute the query after the
commit index at query time is applied. This is called <strong>read_index</strong> optimization.</p>
<p>You can send a R/O command to the cluster with the following API.</p>
<pre><code class="language-proto">message ReadRequest {
  uint32 shard_id = 1;
  bytes message = 2;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cluster-management"><a class="header" href="#cluster-management">Cluster Management</a></h1>
<h2 id="single-server-change-approach"><a class="header" href="#single-server-change-approach">Single server change approach</a></h2>
<p>There are two approaches to membership change.
One is by joint consensus and the other is what is called <strong>single server change approach</strong>.
sorock implements the second one.</p>
<p>This approach exploits the log replication mechanism in membership change
and therefore can be implemented as an extension of the normal log replication
by defining AddServer and RemoveServer commands.
From the admin client, the following API can add or remove a Raft process in the cluster.</p>
<pre><code class="language-proto">message AddServerRequest {
  uint32 shard_id = 1;
  string server_id = 2;
}

message RemoveServerRequest {
  uint32 shard_id = 1;
  string server_id = 2;
}
</code></pre>
<h2 id="cluster-bootstrapping"><a class="header" href="#cluster-bootstrapping">Cluster bootstrapping</a></h2>
<p>In Raft, any command is directed to the leader.
So the question is how to add a Raft process to the empty cluster.</p>
<p>The answer is so-called <strong>cluster bootstrapping</strong>.
On receiving the AddServer command and the receiving node recognizes the cluster is empty,
the node tries to form a new cluster with itself and immediately becomes a leader as a result of a self election.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leadership"><a class="header" href="#leadership">Leadership</a></h1>
<h2 id="command-redirection"><a class="header" href="#command-redirection">Command redirection</a></h2>
<p>Raft is a leader-based consensus algorithm.
Only a single leader can exist in the cluster at a time and
all commands are directed to the leader.</p>
<p>In sorock, if the receiving Raft process isn't the leader,
the command is redirected to the leader.</p>
<h2 id="adaptive-leader-failure-detection"><a class="header" href="#adaptive-leader-failure-detection">Adaptive leader failure detection</a></h2>
<p>Detecting the leader's failure is a very important issue in Raft algorithm.
The naive implementation can send heartbeats to the followers periodically and
followers can detect the leader's failure by timeout.
However, this approach requires the heartbeat interval and the timeout duration
to be set properly before deployment. This brings another complexity.
Not only that, these times can't be fixed to a single value when
the distance between nodes is heterogeneous such as geo-distributed environment.</p>
<p>To solve this problem, sorock uses an adaptive failure detection algorithm called
<strong>Phi accrual failure detector</strong>.
With this approach, users are free from setting the timing parameters.</p>
<h2 id="leadership-transfer-extension"><a class="header" href="#leadership-transfer-extension">Leadership transfer extension</a></h2>
<p>In multi-raft, changing the cluster members is not a rare case.
An example of this case is rebalancing:
To balance the CPU/disk usage between nodes, Raft process may be
moved to other nodes.</p>
<p>If the Raft process to be removed is the leader, the cluster will not have a
leader until a new leader is elected which causes downtime.</p>
<p>To mitigate this problem, the admin client can send a TimeoutNow command to
any remaining Raft process to forcibly start a new election (by promoting to a candidate in Raft term).</p>
<pre><code class="language-proto">message TimeoutNow {
  uint32 shard_id = 1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<p>The proto file should be compiled manually if you changed the proto file.
In this case, please run <code>cargo run -p codegen</code>.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>For testing, sorock makes use of docker-compose.</p>
<p>A docker image called testapp is built and the tests create some instances of it for testing: test code is running on dev container and it accesses the docker deamon in the host. In GHA, the tests are run in the same way.</p>
<p>The log output in the stdout/stderr is collected into the log container. This is quite useful for debugging. So here is how you can run the tests for development.</p>
<ul>
<li><code>docker compose build</code> to build test application.</li>
<li>TERM1: <code>./log</code> to start log watcher.</li>
<li>TERM2: <code>./dev</code> to start the dev container.</li>
<li>TERM2: <code>cargo test</code>.</li>
</ul>
<pre class="mermaid">graph
  subgraph raft_network

  subgraph cluster
  APP1(testapp-1)
  APP2(testapp-2)
  APP3(testapp-3)
  end
  
  DEV(dev)
  LOG(log)
  
  end
  
  APP1 --&gt;|log| LOG
  APP2 --&gt;|log| LOG
  APP3 --&gt;|log| LOG
  
  DEV --&gt;|command| APP1
  DEV --&gt;|command| APP2
  DEV --&gt;|command| APP3
</pre>
<h2 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h2>
<p>You can run benchmark in a similar way as testing.</p>
<ul>
<li><code>docker compose build</code> to build test application.</li>
<li>TERM1: <code>./dev</code></li>
<li>TERM1: <code>cargo +nightly bench</code>.</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>You can modify the documentations.</p>
<p>For editing the mdbook under doc/ directory,
you can run <code>mdbook serve doc</code> to start the local mdbook server.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
